BACK_END Projesi

Bu bir node projesi olduğu için package.json'ı ilk başta oluşturuyoruz
>npm init
entry point yerine server.js
license yerine MIT

projemizi express ile geliştireceğimiz için;
>npm i express

server.js oluşturuyoruz(projemizim entrypoint'i)
Burada projemize dahil edeceğimiz package'larımızı rout'larımızı ve controller'larımızı yerleştireceğiz

expess'i server.js'ye dahil ettikten sonra express'in construction'ından app'i oluşturuyoruz
const app = express();

daha sonra serverımız hangi portta çalışacaksa port değerini vermemiz gerekiyor
const PORT = 5000 

portumuzu da verdikten sonra bu app'imizi artık çalıştırabiliriz
app.listen(PORT,()=>{}) //ilk başta hangi portta çalıştığını daha sonra bir tane fonksiyon gelecek
fonksiyon olarak bir mesaj yayınlayabiliriz.

package.json -> script -> "start" : "node server.js"
>npm run start veya >npm start ile serverı çalıştırabiliriz.

chrome -> localhost:5000 (cannot get / hatası alırız çünkü burada /'ın döndüğü bir response yok. Bunu da geçerli bir response yapmak için app.get("/") yani /'a bir get request olduğunda (req,res)=>{} callback'i dönecek )

ctrl + c ile server'ı kapatabilir sonra >npm start ile tekrar başlatabiliriz.
server'ımızda yaptığımız her değişiklikte server'ı elle kapatıp açmak yerine nodemon modülünü kullanarak otomatik yapabiliriz
>npm i -D nodemon (sadece geliştirme aşamasında işimize yarayacağı için developers kısmına indiriyoruz) 

nodemon'u kullanmak için package.json'da 
"start": "node server.js" yerine "start": "nodemon server.js"
aynı zamanda daha sonra bu start'ı development ortamında değil production yani biz bunu yayınladığımız zaman kullanabiliriz
development ortamında da belli bir komut yazabiliriz
"dev" : "nodemon server.js" npm run dev dediğimizde development ortamını kastettiğimizi belirtebiliriz

şimdi projemizin config dosyasını oluşturacağız
bu config dosyasının içinde projemizin her tarafından erişilebilecek değişkenler olacak mesela port bunlardan bir tanesi.
ancak bunlara erişmemiz için dışarıdan bir tane package'ı kullanmaya çalışıcağız. ilk başta config adında folder olduşturuyoruz.
 config'in altında env(environment variables) yani her taraftan ulaşabileceğimiz veriable'ları depolamak için bir klasör oluşturuyoruz ve 
bunun altında da biz config.env şeklinde dosyamızı oluşturuyoruz

Projemizde her taraftan ulaşabileceğimiz bir tane port olmasını istiyorsam bu port'u config.env'e ekleyebilirim
bu environment klasörünü bu server.js de nasıl kullanacağız? Bunun için dışarıdan bir tane paket indirmemiz gerekiyor
dotenv paketi (https://www.npmjs.com/package/dotenv)

dotenv'i indirmek için bir tane daha terminal açıyoruz
>npm i dotenv
bunu dahil ettikten sonra server.js'de 
const dotenv = require("dotenv");

dotenv'nin config'ini gerçekleştirmek için 
dotenv.config dediğimizde normalde config'in altındaki config.env'e bakıyor ama config'in içinde bir tane daha klasörümüz var bu yüzden biz buraya path'imizi
obje şeklinde vermemiz gerekiyor

dotenv.config({  
    path : "./config/env/condig.env"
})


Bizim projemiz 5 katmandan oluşacak ve biz projemizi mvc yapısıyla yazmaya çalışacağız bildiğimiz gibi express herhangi bir şey dayatmıyor ancak
 biz express projemizi mvc yapısıyla yani module view controller yapısıyla oluşturmaya çalışacağız
Bu back-end api olduğu için burada bizim view katmanımız olmayacak front-end teknolojileriyle beraber bu api'yı 
kullanabileceksiniz(react,angular,vue veya mobil teknolojiler ile bu api kullanılabilir). Bu api'yı test etmek için postman'i kullanacağız.

Projemizde herhangi bir url adresi girdiğimizde yani herhangi bir route girdiğimiz zaman projemiz ilk olarak Routes katmanına bakacak. 
Bu Routes katmanında bizim değişik route'larımız olacak örneğin questionlarla ilgili bir route girmişseniz(api/questions/..) bu Routes katmanı ilgili
controller(Controllers katmanı)'a gönderecek. controller'da örneğin siz bir question oluşturmak istediniz bu da bizim Models(katman) içinde tanımladığımız
mongodb şemalrına(schema) göre bizim modelimizi oluşturacak ve veritabanına kaydedecek

Helpers(katman): yardımcı fonksiyonlarımızı barındıran katmanımız olacak örneğin biz dışarıdan başka libraryler kullanmaya çalışacağız bu kütüphanelerin 
kullanımını daha kolaylaştırmak için bizim değişik fonksiyonlarımız olacak ve biz de bunlara helper fonksiyon diyeceğiz.
Middlewares(katman): kısıtlamalar, önlemler.

şimdi express'ib routlarını ayarlamaya çalışacağız
örneğin /api/questions geldiğinde questions'a gitmesini sağlayacağız

/////////////////////////////////////////////
app.get("/api/questions",(req,res) => {
    res.send("Questions Home Page");
})
app.get("/api/delete",(req,res) => {
    res.send("Delete Home Page");
})
app.get("/api/auth",(req,res) => {
    res.send("Auth Home Page");
})
app.get("/api/auth/register",(req,res) => {
    res.send("Register Delete Page");
})

app.listen(PORT, () => {
    console.log(`App started on ${PORT} : ${process.env.NODE_ENV}`);
})

şimdi bu route'ları server.js'e yazdık şimdi de ayırmaya çalışacağız
çünkü bir süre sonra kodun bakımı zor olacak değişime oldukça kapalı olacak biz; ne, nerede bulmakta zorlanacağız o yüzden projenin routlarını modüler hale getirmeye çalışacağız 
uygulamamızda bizim api/question yazdığımızda question route'na gitmemiz gerekiyor. Bunun için de biz express router kullanmamız gerekiyor.
Örneğin server.js yer alıyor, buraya api/question gibi istekler gelecek ve biz bunları route klasörünün altında gereken yere göndereceğiz.
Örneğin /question gelmişse bunu question router'ına yönlendireceğiz /auth gelmişse auth router'ına yönlendireceğiz

routers klasörünün altıda olusturduğumuz js dosyalarına expressi dahil ediyoruz ve router = express.Router(); ile Router'ı tanımlıyoruz module.exports = router ile router'ı dışarıya aktarıyoruz
router.get || router.post || router.put ile requestlerimizi alabiliriz.

şimdi question.js ve auth.js'e göre yönlendirme yapmam gerekiyor örneğin /api/questions ile question.js'e gelmeli aynı şekilde api/auth ile auth.js'deki router.get("/",(req,res) =>{})'e veya api/auth/resgister'a istek atıldığında router.get("/register") çalışmalı
bunu kullanmak için server.js'e geliyoruz ve ,lk başta routerları dahil etmek istiyorum
const question = require("./routers/question");
const auth = require("./routers/auth");

bunları kullanmak için 
herhangi bir middleware kullanmak için app.use kullanılır
app.use("api/question",question); api/question olduğunda quetion route'na gidiyoruz
app.use("api/auth",auth);

bunları daha modüler hale getirebiliriz
index.js adında ana bir dosyada ayarlayabiliriz

server.js de  app.use("api/question",question); 
              app.use("api/auth",auth); yerine app.use("/api",routers);
const routers = require("./routers/index);
https://stackoverflow.com/questions/21063587/what-is-index-js-used-for-in-node-js-projects


Controllers klasörünü projeyi daha modüler yapmak için oluşturduk.

res.send ->text,html etiketi res.json ->json dönüyor
postman ile server'a istekler atabiliriz
///MongoDB///
google'dan mongodb cloud aratıyoruz(https://cloud.mongodb.com/v2/6141a3e5eb8ae263cfe65ee7#clusters)

https://mongoosejs.com/docs/guide.html
mongoose: mongodb'nin modellenmesi için kullanılan npm paketi. Bunun sayesinde veritabanına bağlanabiliyoruz, veritabanımızdaki herhangi bir objeyi değiştirebiliyoruz..
mongoose'u kullanmadan önce veritabanına mongoose ile bağlanmamız gerekiyor
>npm i mongoose

https://mongoosejs.com/docs/connections.html   bağlantı kurma rehberi
config.env altına mongodb baplantı URI'ını veriyoruz
bağlantı için yardımcı middleware ve başka middlewareler için helpers klasörünü oluşturuyoruz
+connectDatabase.js
connectDatabase'i server.js 'de kullanacağız

User modeli oluşturma : 
bu modeli oluşturmak için mongoose'u kullanacağız
https://mongoosejs.com/docs/models.html

models adında folder oluşturuyoruz
burada veritabanında bulunan objelerimiz yer alacak. Objelerimizin definasyonu yani tanımları yer alacak
Controllers>auth.js'ye User'ı dahil ediyoruz
const User = require("../models/User");

auth.js 'deki register fonksiyonuna post verilerimiz gelecek

asenkron işlemlerde express errorhandler yakalayamıyor. Peki express bunu nasıl yakalayacak? Kodu try catch bloğuna alıp next ile göndereceğiz
kullanıcıyı veritabanına eklemek için kullanıcıdan aldığımız verilerle..
await User.create({
    name : name,
    email : email,
    password : password
});
ile veritabanına kaydediyoruz
verimiz await yapısıyla beklenecek eğer herhangi bir sıkıntı çıkmazsa bize olusturulan kayıt gelecek biz de bunu user ile alacağız
const user = await User.create({
    name : name,
    email : email,
    password : password
});

/////HATA YAKALAMA
hata yakalama bir api projesindeki en önemli kısımlardan biridir.
https://expressjs.com/en/guide/error-handling.html
express'te 2 tane errorhandling mekanizması var. Birinci kullanımı senkron kodları yakalama.
mesela senkron kodunun herhangi bir yerinde bir hata olursa express burada kendi içine gömülü bir errorhandling mekanizmasıvar ve bunu yakalayabiliyor.
ancak expressin yakalayamadığı durumlar da mevcut bu durumlar da asenkron kodlarda eğer herhangi bir hata olursa
express bunları yakalayamıyor. Peki expressin bunu yakalaması için ne yapmamız gerekiyor? herhangi bir hata varsa bu hatayı 
mutlaka next parametresiyle göndermemiz gerekiyor. Eğer hatayı next paremetresiyle express'e gönderirsek express bunu yine kendisi halledecektir.

const errorTest = (req,res,next) => {
    //some code
    throw new Error("Bir hata olustu"); //bu andan itibaren express bunu direkt olarak kendi içindeki errorhandling mekanizmasıyla yakalayacak ve bize response'muzu dönecek. Yani programımız patlamadı
    //some code
}//bu hata senkron kod içinde olduğu için express bu hatayı yakalayacak

istersek kendi errorhandling mekanizmamızla hataları yakalayabiliriz.
middleware klasörü oluşturuyoruz
app.use(customErrorHandler); (middleware)-> server.js'de
request gerçekleştiğinde bu request ilk başta kendi yazdığımız errorhandling'e gelmesi gerekiyor. Eğer burada bir hata varsa bu hatayı aynı şekilde geri döndürmemiz gerekiyor.

customErrorHandler da err parametresi kullandığımız için express'in kendi içinde bulunan error handling mekanizması herhangi bir hata yakaladığı zaman bunu direkt customErrorHandler'a gönderiyor

/////////////////////////////////////////////////////
//  Using Async/await in Express:                  //
//  https://zellwk.com/blog/async-await-express/   //
/////////////////////////////////////////////////////

async kodları try catch olmadan direkt customErrorHandler'a yönlendireceğiz
her sefeerinde try catch'leri yazmak hem kodumuzu karmaşık hale getirecek hem de bizim bu kodu yönetmemiz zor olacak.
bunun için merkezi async handler oluşturacağız (modulu kullanacağız). Her async fonksiyonumuzu kapsayacak bir async wrapper fonksiyon oluşturacağız  


>npm install express-async-handler   (https://www.npmjs.com/package/express-async-handler)


->auth(controller)
const register =async (req,res,next) => {
    const name = "Ömercan Yeşil";
    const email = "omercanyesil@gmail.com";
    const password = "12345";
    try{

       const user =  await User.create({
            name,
            email,
            password
        });
        res
        .status(200)
        .json({
            succes: true,
            data : user
        })
    }
    catch (err){
        return next(err);
    }
 }


Şimdi gönderdiğimiz parolayı şifrelemeye çalışacağız. 
postmande gönderdiğimiz verilere göre modelimizi user.create ile oluşturuyoruz; ancak mongoose'da modelimizi kaydetmeden hemen önce kullanabileceğimiz belli metodlar ve bunlarada hooks adı veriliyor.
https://mongoosejs.com/docs/middleware.html#pre

//Parola Hashleme
https://www.npmjs.com/package/bcryptjs
>npm install bcryptjs

>User.js
parolayı hash'leyip güncelleme
Burada this parametresi iç içe funtion kullandığımız için kayboldu. Arrow Function ile bu meseleyi halledebiliriz

UserSchema.pre("save",function(err,next){ 
    if(err) next(err);
        bcrypt.genSalt(10, function(err, salt) {
        bcrypt.hash(this.password, salt, function(err, hash) {
           if(err) next(err);
           this.password = hash;
           next();
        });
    });
});



//JWT video 248
kullanıcı serverdaki belli routlara gittiği zaman(like,edit vb.) oturum kontrolü yapmamız gerekiyor(bu kullanıcı oturum açmış mı?)(json web token)
bu jwt'yi authorization header'ın içine yerleştireceğiz. daha sonra bu token bizim api'mize gidecek eğer bu token'nın süresi geçmişse api token'ı decode edemeyecek ve geriye 401 unauthorized gönderecek ama token hala geçerliyse api bu 
tokenı çözebildiği için bu tokenın hangi kullanıcıy ait olduğunu bildiği için de 200 sonucunu döndürecek. jwt'yi cookielerde depolaycağız.

https://jwt.io/introduction
https://www.npmjs.com/package/jsonwebtoken
>npm install jsonwebtoken

bu token'ı oluşturmak için user modelimize bir tane metod eklememiz gerekiyor mongoose sayesinde bu da mümkün
daha sonra bu modelden oluşan herhangi bir kaydın üzerinde bu metodu kullanabiliriz.


Şimdi token'ı üretip bunu cookie'ye kaydedeceğiz.
Express Cookie
http://expressjs.com/en/4x/api.html#res.cookie

bunu register'da ve login işleminde response'da token'ı göndereceğiz ve aynı zamanda cookie'ye tekrardan kaydedeceğiz. 
Bunun için bu işlemleri tekrarlamayalım diye bir tane helper fonksiyon yazmaya çalışacağız.

postmande access_token'ımızın değerini global enviroment'ımıza eklemeye çalışalım
https://community.postman.com/t/how-to-set-and-get-dynamic-environmental-variable/7482

artık token'ı kullanrak belli routlara erişimi ksıtlayacağız. Örneğin giriş yapmamış bir kullanıcı ya da token'ının süresi geçmiş bir kullanıcı belli routlara erişemeyecek.
gelen request'i ilk önce middleware'den geçirmeliyiz eğer route'a requesti yapan kullanıcının token'ı yoksa veya geçmişse geriye hata mesajı göndereceğiz.
requestlerde tokenları headers bölümünde gönderiyoruz.
key -> authorization | value ->{{access_token}}  //node ve express geliştiricileri genel olarak access_token'ın başına bearer yani taşıyıcı şeklinde bir tane kısım koyuyorlar. Bu bunun token olduğunu belirtiyor.



//Multer, öncelikle dosyaları yüklemek için kullanılan, çok parçalı/form verilerini işlemeye yönelik bir node.js middleware'idir.
https://www.npmjs.com/package/multer
257.video



https://nodemailer.com/about/
https://stackoverflow.com/questions/26196467/sending-email-via-node-js-using-nodemailer-is-not-working


//URL slug
//https://www.thecastofcheers.com/blog/url-slug-nedir-ve-web-sitenizi-optimize-etmek-icin/
https://www.npmjs.com/package/slugify
>npm i slugify



https://javascript.info/regexp-introduction


//Merkezi Answer Query Middleware
Bir tane question elde ettiğimiz zaman //router.get("/:id",checkQuestionExist,getSingleQuestion)
bu sefer de alttaki answers arrayimizi paginate etmeye ve buradaki pupolate işlemini gerçekleştireceğiz yazdığımız middlewareler sayesinde 
ancak bunu yapmadan önce birkaç tane refactoring işlemini yapmamız gerekiyor (Refactoring, kodun işlevselliğini değiştirmeden, kodun kalitesinin artırılması sürecidir.)

querymiddlewarehelpers
const paginationHelper = async(model,query,req) => {
    
    const page = parseInt(req.query.page) || 1; //string olarak geliyorlar
    const limit = parseInt(req.query.limit) || 5;

    const startIndex = (page-1) * limit;
    const endIndex = page * limit;

    const pagination = {};
    const total = await model.countDocuments(); //mongoose  //direkt question.countDocument yerine model yazıyoruz çünkü answer'da bu middleware'i kullanabilir.

    if(startIndex > 0) {
        pagination.previous = { //önceki sayfanın bilgileri
            page : page-1,
            limit : limit
        }
    }
    if(endIndex < total){
        pagination.next = {
            page : page + 1,
            limit : limit
        }        
    }
    // console.log(pagination);
    return {
        query : query.skip(startIndex).limit(limit), //mongoose
        pagination : pagination
    }
}; //burada model göndermiştik ancak biz bu sefer model gönderemeyiz çünkü bu questionumuzun altındaki answers'ın içeriğine bakmaya çalışacağız yani burada model.countDocument yapamıyoruz
o yüzden bunu burada yapmak yerine buraya model yerine totalDocuments değerini göndereceğiz.
const total = totalDocuments

aynı zamanda burada querymizi değil başka bir yöntemi kullanacağız o yüzden querymiz bazen undefined gelecek. querymiz undefined geleceği için bunu kontrol etmem gerekiyor.

questinQueryMiddleware -> const paginationResult = await paginationHelper(model,query,req); burada model yerine total göndereceğiz
